We assumed that the client and the server had a bounded memory, however the accumulation of slices and borders make the size of the history of the client and the servor grow linearly in the number of node added. To keep a memory bounded by a constant $M$ the following algorithm ensures that merging two processes with a small difference in their history will still be efficient but we may loose efficiency when trying to find older nodes : When adding nodes we check wether the size is greater than $M$ or not, if it is we part the sorted list of slices in two and we remove half of the slices and according borders of the oldest half, thus reducing the size to $\frac{3M}{4}$ and forgetting a part of once history. This algorithm will still be effective but we loose in efficiency beacause the server will assume that the client does not know some nodes it actually knew and the server will send them to the client. We keep the first half intact because in real-life applications most of the merging happens between the newest nodes, ensuring that the algorithm will remain efficient on such merges.