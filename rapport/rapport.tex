\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fontenc}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{mathrsfs}
\usepackage[usenames,dvipsnames]{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\providecommand{\SetAlgoLined}{\SetLine}
\providecommand{\DontPrintSemicolon}{\dontprintsemicolon}
\title{Efficient synchronization of DAGs}
\author{Matthieu JOURNAULT}
\date{24/06/2013}
\theoremstyle{definition}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\theoremstyle{definition}

\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{arrows}
\usetikzlibrary{chains,fit,shapes}
\usepackage{fullpage}
\definecolor{turquoise}{RGB}{255,127,0}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
      zigzag/.style = {->,black,very thick,line join=round,
decorate, decoration={
    zigzag,
    segment length=4,
    amplitude=.9,post=lineto,
    post length=2pt
}},
zigzagred/.style = {->,red,very thick,line join=round,
decorate, decoration={
    zigzag,
    segment length=4,
    amplitude=.9,post=lineto,
    post length=2pt
}},
  arn_bb/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
    fill=white, text width=2.5em, very thick},% arbre rouge noir, noeud noir
  arn_ns/.style = {treenode, rectangle, white, font=\sffamily\bfseries, draw=black,
    fill=black, minimum width=1.5em, minimum height=1.5em, very thick},% arbre rouge noir, noeud noir
  arn_n/.style = {treenode, circle , white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
    arn_nb/.style = {treenode, circle , white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=2.5em},
  arn_r/.style = {treenode, circle , red, draw=red, 
    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
  arn_x/.style = {treenode, rectangle, draw=black,
    minimum width=1em, minimum height=1em},% arbre rouge noir, nil
  arn_b/.style = {treenode, circle , blue, draw=blue, 
    text width=1.5em, very thick},
  arn_g/.style = {treenode, circle , green, draw=green, 
    text width=1.5em, very thick},
  arn_y/.style = {treenode, circle , yellow, draw=yellow, 
    text width=1.5em, very thick},
    arn_pu/.style = {treenode, circle , purple, draw=purple, 
    text width=1.5em, very thick},
    arn_pi/.style = {treenode, circle , pink, draw=pink, 
    text width=1.5em, very thick},
    arn_t/.style = {treenode, circle , pink, draw=turquoise, 
    text width=1.5em, very thick},
    arn_rb/.style = {treenode, circle , red, draw=red, 
    text width=2.5em, very thick},
    arn_bs/.style = {treenode, rectangle , blue, draw=blue, 
    minimum width=1.5em, minimum height=1.5em, very thick},
    arn_rs/.style = {treenode, rectangle, red, draw=red, 
    minimum width=1.5em, minimum height=1.5em, very thick},% arbre rouge noir, noeud rouge
  arn_gs/.style = {treenode, rectangle , green, draw=green, 
    minimum width=1.5em, minimum height=1.5em, very thick},
  arn_ys/.style = {treenode, rectangle , yellow, draw=yellow, 
    minimum width=1.5em, minimum height=1.5em, very thick},
    arn_pus/.style = {treenode, rectangle , purple, draw=purple, 
    minimum width=1.5em, minimum height=1.5em, very thick},
    arn_pis/.style = {treenode, rectangle , pink, draw=pink, 
    minimum width=1.5em, minimum height=1.5em, very thick},
    arn_rbs/.style = {treenode, rectangle , red, draw=red, 
    minimum width=1.5em, minimum height=1.5em, very thick},
    arn_ts/.style = {treenode, rectangle, pink, draw=turquoise, 
    minimum width=1.5em, minimum height=1.5em, very thick},
    }% arbre rouge noir, noeud rouge}
\input{caml.tex}
\begin{document}
\maketitle
\tableofcontents
% \begin{lstlisting}
% 
% \end{lstlisting}
\begin{figure}[H]
\begin{tikzpicture}
\begin{scope}
\coordinate (A) at (0,0);
\coordinate (B) at (4,10);
\coordinate (C) at (-4,10);
\draw [thick] (A) -- (B) coordinate[pos = 0.4] (B1) {} coordinate [pos = 0.42] (B1b) {} coordinate[pos = 0.7] (B2) {} coordinate[pos = 0.72] (B2b) {};
\draw [thick] (B) -- (C) coordinate[pos = 0.5] (midBC) {};
\draw [thick] (A) -- (C) coordinate[pos = 0.5] (C1) {} coordinate [pos = 0.52] (C1b) {} coordinate[pos = 0.8] (C2) {} coordinate[pos = 0.82] (C2b) {};
\draw [thick, fill = LimeGreen,fill opacity = 0.5] (A) -- (B1) .. controls (1,3) and (-1,7) .. (C1) -- (A);
\draw [thick, fill = green,fill opacity = 0.5] (B1) .. controls (1,3) and (-1,7) .. (C1) -- (C2) .. controls (-2,6) and (2,8) .. (B2) -- (B1);
\draw [thick, fill = ForestGreen, fill opacity = 0.5] (C2) .. controls (-2,6) and (2,8) .. (B2) -- (B) -- (C) -- (C2);
\draw [thick, fill = red, fill opacity = 1] (B1b) .. controls (1,3.1) and (-1,7.1) .. (C1b) -- (C1) .. controls (-1,7) and (1,3) .. (B1) -- (B1b);
\draw [thick, fill = red, fill opacity = 1] (C2) .. controls (-2,6) and (2,8) .. (B2) -- (B2b) .. controls (2,8.1) and (-2,6.1) .. (C2b) -- (C2);
\draw [draw = none] (A) -- (midBC) node[pos = 0.3] {$A_0$} node[pos = 0.6] {$A_1$} node[pos = 0.9] {$A_2$};

\end{scope}
\begin{scope}[shift={(4cm,0cm)}]
\coordinate (D) at (0,0);
\coordinate (E) at (4,10);
\coordinate (F) at (-4,10);
\draw [thick] (D) -- (E) coordinate[pos = 0.5] (E1) {} coordinate [pos = 0.52] (E1b) {} coordinate[pos = 0.8] (E2) {} coordinate[pos = 0.82] (E2b) {};
\draw [thick] (E) -- (F) coordinate[pos = 0.5] (midEF) {};
\draw [thick] (D) -- (F) coordinate[pos = 0.3] (F1) {} coordinate [pos = 0.32] (F1b) {} coordinate[pos = 0.6] (F2) {} coordinate[pos = 0.62] (F2b) {};
\draw [thick, fill = Cerulean,fill opacity = 0.5] (D) -- (E1) .. controls (1,3) and (-1,7) .. (F1) -- (D);
\draw [thick, fill = blue,fill opacity = 0.5] (E1) .. controls (1,3) and (-1,7) .. (F1) -- (F2) .. controls (-2,6) and (2,8) .. (E2) -- (E1);
\draw [thick, fill = SkyBlue, fill opacity = 0.5] (F2) .. controls (-2,6) and (2,8) .. (E2) -- (E) -- (F) -- (F2);
\draw [thick, fill = red, fill opacity = 1] (E1b) .. controls (1,3.1) and (-1,7.1) .. (F1b) -- (F1) .. controls (-1,7) and (1,3) .. (E1) -- (E1b);
\draw [thick, fill = red, fill opacity = 1] (F2) .. controls (-2,6) and (2,8) .. (E2) -- (E2b) .. controls (2,8.1) and (-2,6.1) .. (F2b) -- (F2);
\draw [draw = none] (D) -- (midEF) node[pos = 0.3] {$B_0$} node[pos = 0.6] {$B_1$} node[pos = 0.9] {$B_2$};
\end{scope}
\end{tikzpicture}
\end{figure}

\chapter{Introduction and scientific context}
\chapter{Research subject}
\section{Introduction to the problem}
\input{pb.tex}
\section{Introduction to Bloomfilters}
\input{bf.tex}
\chapter{Results}
\section{Preliminary result on Dags and Bloomfilters}
As we change the problem from a finite and known number of process with at most one biggest common ancestor (BCA) to an unknown number of processes with no restriction on the number of BCA, it is important to study what will change and what do we have to expect regarding the number of BCA. Therefore using a DAG random generator (see section~\ref{sec:daggen}) we started by implementing the same algorithm that the one used on a finite and known number of process, except that we now assume that each node $a$ of the DAG contains a hash $h(a)$ of size $k$. We label every node $a$ of the tree with a vector $v(a)$ such that $v(a)_i=\sum_{b\in \mathrm{ancestor}(a)} h(b)_i$, with this labeling we test wether the proposition \ref{propmin} can still be used in some way. We already know that we have the relation :
\begin{proposition}
 If $c$ is a biggest common ancestor of $a$ and $b$ then $\mathrm{label}(c) \leq \mathrm{min}(\mathrm{label}(a),\mathrm{label}(b))$. \label{propinf}
\end{proposition}
In our Dag algorithm nodes are placed in different layers, each layers having links only with the previous and the next one. An important parameter to consider is the probability for a node that a node from the previous layer is one of its parents. Examples of the influence of this parameter (called $p$) can be found in section~\ref{sec:daggen}. The "high" of a DAG is the length of the biggest path between two nodes of the DAG. The next graphs show the influence of $p$ and the high of the DAG on the number of BCA and on the number of element verifying the proposition \ref{propinf}.
\begin{figure}[H]
  \centering
 \begin{subfigure}[b]{0.49 \textwidth}
  \includegraphics[width = \textwidth]{./image/resultprelim/averagenbbca.png}
  \caption{Number of Biggest Common Ancestor in a DAG with 100 nodes}
 \end{subfigure}
 \begin{subfigure}[b]{0.49 \textwidth}
  \includegraphics[width = \textwidth]{./image/resultprelim/averagenum.png}
  \caption{Number of element verifying the inequality of \ref{propinf} in a DAG with 100 nodes}
 \end{subfigure}
\end{figure}

\section{Hash Functions}
\input{hash.tex}
\section{Algorithm}
\subsection{General algorithm}
\input{algo.tex}
\subsection{The False-positive case}
\input{fp.tex}
\section{Evaluation}
\chapter{Conclusion and bibliography}
%   \input{biblio.tex}
\chapter{Appendix}
\section{DAG Generator}
\label{sec:daggen}
\input{daggen.tex}
%   \input{algo.tex}



\end{document}

